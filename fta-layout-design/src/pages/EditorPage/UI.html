<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UI 组件标注工具 (V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        overscroll-behavior: none;
      }
      .main-grid {
        grid-template-columns: 280px 1fr 320px;
      }
      canvas {
        cursor: crosshair;
        touch-action: none;
      }
      .component-item.selected {
        background-color: rgb(219, 234, 254);
        border-color: rgb(59, 130, 246);
      }
      .layer-item.selected {
        background-color: rgb(224, 231, 255);
        border-left-color: rgb(79, 70, 229);
      }
      .layer-item.is-slot-child {
        background-color: rgb(245, 243, 255); /* 淡紫色背景用于插槽内组件 */
      }
      .layer-item.is-slot-child.selected {
        background-color: rgb(221, 214, 254);
      }
      .panel-header {
        border-bottom: 1px solid rgb(229, 231, 235);
      }
      /* Message Toast Styles */
      .message-container {
        position: fixed;
        top: 24px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        pointer-events: none;
      }
      .message-toast {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgb(255, 255, 255);
        border-radius: 8px;
        padding: 12px 20px;
        margin-bottom: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        animation: slideInDown 0.3s ease-out;
        pointer-events: auto;
        max-width: 500px;
      }
      .message-toast.warning {
        border-left: 4px solid rgb(250, 173, 20);
      }
      .message-toast.error {
        border-left: 4px solid rgb(255, 77, 79);
      }
      .message-toast.info {
        border-left: 4px solid rgb(24, 144, 255);
      }
      .message-toast.success {
        border-left: 4px solid rgb(82, 196, 26);
      }
      .message-toast.hiding {
        animation: slideOutUp 0.3s ease-in forwards;
      }
      @keyframes slideInDown {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes slideOutUp {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-20px);
        }
      }
      .message-icon {
        flex-shrink: 0;
        font-size: 16px;
      }
      .message-text {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
      }
      /* Tree Structure Styles */
      .layer-item {
        display: flex;
        align-items: center;
        transition: background-color 0.15s ease;
      }
      .layer-item:hover {
        background-color: rgba(0, 0, 0, 0.03);
      }
      .tree-toggle {
        display: inline-block;
        width: 16px;
        height: 16px;
        font-size: 10px;
        color: rgb(107, 114, 128);
        user-select: none;
        cursor: pointer;
        text-align: center;
        line-height: 16px;
        border-radius: 2px;
        transition: all 0.15s ease;
      }
      .tree-toggle:hover {
        background-color: rgba(0, 0, 0, 0.1);
        color: rgb(17, 24, 39);
      }
      .layer-children {
        overflow: hidden;
      }
      .layer-item-wrapper {
        margin-bottom: 2px;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800 antialiased">
    <!-- Message Container -->
    <div id="message-container" class="message-container"></div>
    
    <div
      id="app"
      class="h-screen w-screen grid main-grid gap-4 p-4 overflow-hidden"
    >
      <!-- Left Panel: Component Palette -->
      <div class="bg-white rounded-lg shadow-md flex flex-col overflow-hidden">
        <header class="panel-header p-4">
          <h2 class="text-lg font-semibold text-gray-900">
            组件库 (FTA Mobile)
          </h2>
          <p class="text-sm text-gray-500 mt-1">点击一个组件开始标注</p>
        </header>
        <div id="component-palette" class="p-4 space-y-4 overflow-y-auto">
          <!-- Components will be injected here by JS -->
        </div>
      </div>

      <!-- Center Panel: Canvas -->
      <div class="bg-white rounded-lg shadow-md flex flex-col overflow-hidden">
        <header class="panel-header p-4 flex justify-between items-center">
          <h2 class="text-lg font-semibold text-gray-900">标注画布</h2>
          <div class="flex items-center space-x-2">
            <span id="instruction" class="text-sm text-indigo-600 font-medium"
              >请先加载一张图片</span
            >
            <button
              id="upload-btn"
              class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition text-sm font-medium"
            >
              加载示例图片
            </button>
          </div>
        </header>
        <main
          class="flex-grow p-4 bg-gray-50 flex items-center justify-center relative overflow-auto"
        >
          <div id="canvas-container" class="relative w-full h-full">
            <canvas
              id="annotation-canvas"
              class="absolute top-0 left-0"
            ></canvas>
          </div>
          <div id="placeholder-text" class="text-gray-400">画布区域</div>
        </main>
      </div>

      <!-- Right Panel: Layers & Properties -->
      <div class="flex flex-col gap-4">
        <div class="bg-white rounded-lg shadow-md flex flex-col h-1/2">
          <header class="panel-header p-4 flex justify-between items-center">
            <h2 class="text-lg font-semibold text-gray-900">图层结构</h2>
            <div class="flex gap-2">
              <button id="expand-all-btn" class="text-xs text-indigo-600 hover:text-indigo-700 font-medium px-2 py-1 rounded hover:bg-indigo-50 transition">
                展开全部
              </button>
              <button id="collapse-all-btn" class="text-xs text-gray-600 hover:text-gray-700 font-medium px-2 py-1 rounded hover:bg-gray-100 transition">
                收起全部
              </button>
            </div>
          </header>
          <div id="layer-panel" class="p-4 space-y-2 overflow-y-auto">
            <p class="text-sm text-gray-400 text-center">暂无标注</p>
          </div>
        </div>
        <div class="bg-white rounded-lg shadow-md flex flex-col h-1/2">
          <header class="panel-header p-4">
            <h2 class="text-lg font-semibold text-gray-900">属性检查器</h2>
          </header>
          <div id="property-inspector" class="p-4 overflow-y-auto">
            <p class="text-sm text-gray-400 text-center">请选择一个图层</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      // --- MESSAGE TOAST SYSTEM ---
      const messageContainer = document.getElementById("message-container");
      
      const icons = {
        warning: '⚠️',
        error: '❌',
        info: 'ℹ️',
        success: '✅'
      };

      function showMessage(text, type = 'warning', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `message-toast ${type}`;
        toast.innerHTML = `
          <span class="message-icon">${icons[type]}</span>
          <span class="message-text">${text}</span>
        `;
        
        messageContainer.appendChild(toast);
        
        // Auto remove after duration
        setTimeout(() => {
          toast.classList.add('hiding');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300); // Match animation duration
        }, duration);
      }

      // --- 1. CONFIGURATION & STATE ---
      const components = {
        基础原子组件: [
          { name: "Button", category: "atomic" },
          { name: "Icon", category: "atomic" },
          { name: "Text", category: "atomic" },
          { name: "Avatar", category: "atomic" },
          { name: "Badge", category: "atomic" },
          { name: "Tag", category: "atomic" },
          { name: "Image", category: "atomic" },
          { name: "ProgressBar", category: "atomic" },
          { name: "CircularProgress", category: "atomic" },
          { name: "InputNumber", category: "atomic" },
          { name: "Radio", category: "atomic" },
          { name: "Toggle", category: "atomic" },
          { name: "Divider", category: "atomic" },
          { name: "Loading", category: "atomic" },
        ],
        带有插槽的复杂组件: [
          { name: "Card", category: "slot" },
          { name: "ListItem", category: "slot" },
          { name: "NavBar", category: "slot" },
          { name: "FormItem", category: "slot" },
          { name: "Input", category: "slot" },
          { name: "Search", category: "slot" },
          { name: "Collapse", category: "slot" },
          { name: "Timeline.Item", category: "slot" },
          { name: "Result", category: "slot" },
          { name: "Modal", category: "slot" },
        ],
        复杂整体业务组件: [
          { name: "AddressPicker", category: "business" },
          { name: "CarKeyboard", category: "business" },
          { name: "ImageUpload", category: "business" },
          { name: "Calendar", category: "business" },
          { name: "Cascader", category: "business" },
          { name: "SelectorCore", category: "business" },
          { name: "InfiniteScroll", category: "business" },
          { name: "Lottie", category: "business" },
        ],
        基础容器: [
          { name: "Container", category: "container" },
          { name: "Flex", category: "container" },
          { name: "Grid", category: "container" },
        ],
      };

      const state = {
        isDrawing: false,
        imageLoaded: false,
        startPos: { x: 0, y: 0 },
        currentRect: { x: 0, y: 0, width: 0, height: 0 },
        selectedComponent: null, // { name, category }
        annotations: [], // Tree structure
        selectedAnnotationId: null,
        nextId: 0,
        expandedNodes: new Set(), // 记录展开的节点 ID
      };

      const image = new Image();
      image.src =
        "https://imagecdn.ymm56.com/ymmfile/static/resource/9ce8fe49-014d-47e2-9a7e-0ebd52c9b7f4.png";

      // --- 2. DOM ELEMENTS ---
      const canvas = document.getElementById("annotation-canvas");
      const ctx = canvas.getContext("2d");
      const canvasContainer = document.getElementById("canvas-container");
      const componentPalette = document.getElementById("component-palette");
      const layerPanel = document.getElementById("layer-panel");
      const propertyInspector = document.getElementById("property-inspector");
      const uploadBtn = document.getElementById("upload-btn");
      const instruction = document.getElementById("instruction");
      const placeholderText = document.getElementById("placeholder-text");
      const expandAllBtn = document.getElementById("expand-all-btn");
      const collapseAllBtn = document.getElementById("collapse-all-btn");

      // --- 3. UTILITY FUNCTIONS ---
      function findAnnotation(id, searchTree = state.annotations) {
        for (const anno of searchTree) {
          if (anno.id === id) return anno;
          const found = findAnnotation(id, anno.children);
          if (found) return found;
        }
        return null;
      }

      function deleteAnnotation(id, searchTree = state.annotations) {
        for (let i = 0; i < searchTree.length; i++) {
          if (searchTree[i].id === id) {
            searchTree.splice(i, 1);
            return true;
          }
          if (deleteAnnotation(id, searchTree[i].children)) {
            return true;
          }
        }
        return false;
      }

      function forEachAnnotation(callback, nodeArray = state.annotations) {
        for (const anno of nodeArray) {
          callback(anno);
          forEachAnnotation(callback, anno.children);
        }
      }

      function rectsIntersect(r1, r2) {
        return !(
          r2.x >= r1.x + r1.width ||
          r2.x + r2.width <= r1.x ||
          r2.y >= r1.y + r1.height ||
          r2.y + r2.height <= r1.y
        );
      }

      function isInside(childRect, parentRect) {
        return (
          childRect.x >= parentRect.x &&
          childRect.y >= parentRect.y &&
          childRect.x + childRect.width <= parentRect.x + parentRect.width &&
          childRect.y + childRect.height <= parentRect.y + parentRect.height
        );
      }

      // --- 4. RENDERING & DRAWING ---

      function populateComponentPalette() {
        let html = "";
        for (const categoryTitle in components) {
          html += `<div class="space-y-2">
                            <h3 class="text-sm font-semibold text-gray-600">${categoryTitle}</h3>
                            <div class="grid grid-cols-2 gap-2">`;
          components[categoryTitle].forEach((comp) => {
            let color = "bg-blue-100 text-blue-800";
            if (comp.category === "slot") color = "bg-green-100 text-green-800";
            else if (comp.category === "business")
              color = "bg-purple-100 text-purple-800";
            else if (comp.category === "container")
              color = "bg-gray-100 text-gray-800";
            html += `<div class="component-item p-3 border rounded-lg cursor-pointer hover:border-indigo-500 transition ${color}" data-name="${comp.name}" data-category="${comp.category}">
                                <span class="font-medium text-sm">${comp.name}</span>
                             </div>`;
          });
          html += `</div></div>`;
        }
        componentPalette.innerHTML = html;
      }

      function resizeCanvas() {
        if (!state.imageLoaded) return;
        const containerRect = canvasContainer.getBoundingClientRect();
        const imageAspectRatio = image.width / image.height;
        const containerAspectRatio = containerRect.width / containerRect.height;
        let newWidth, newHeight;
        if (imageAspectRatio > containerAspectRatio) {
          newWidth = containerRect.width;
          newHeight = containerRect.width / imageAspectRatio;
        } else {
          newHeight = containerRect.height;
          newWidth = containerRect.height * imageAspectRatio;
        }
        canvas.width = newWidth;
        canvas.height = newHeight;
        canvas.style.top = `${(containerRect.height - newHeight) / 2}px`;
        canvas.style.left = `${(containerRect.width - newWidth) / 2}px`;
        draw();
      }

      function draw() {
        if (!state.imageLoaded) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        forEachAnnotation((anno) => {
          const isSelected = state.selectedAnnotationId === anno.id;
          const isRoot = anno.properties?.isRoot;

          // 页面根节点使用特殊样式
          if (isRoot) {
            ctx.strokeStyle = isSelected ? "rgb(16, 185, 129)" : "rgb(107, 114, 128)";
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.setLineDash([8, 4]); // 虚线边框

            // 绘制页面根节点边框
            ctx.strokeRect(
              anno.rect.x,
              anno.rect.y,
              anno.rect.width,
              anno.rect.height
            );
            ctx.setLineDash([]);

            // 页面根节点标签
            const label = anno.properties?.name || anno.componentName;
            ctx.fillStyle = isSelected ? "rgb(16, 185, 129)" : "rgb(107, 114, 128)";
            ctx.fillRect(
              anno.rect.x,
              anno.rect.y - 25,
              ctx.measureText(label).width + 12,
              22
            );
            ctx.fillStyle = "rgb(255, 255, 255)";
            ctx.font = "12px Inter";
            ctx.fillText(label, anno.rect.x + 6, anno.rect.y - 8);
          } else {
            // 普通组件样式
            ctx.strokeStyle = isSelected ? "rgb(245, 158, 11)" : "rgb(59, 130, 246)";
            ctx.lineWidth = isSelected ? 4 : 2;
            ctx.strokeRect(
              anno.rect.x,
              anno.rect.y,
              anno.rect.width,
              anno.rect.height
            );

            ctx.fillStyle = isSelected ? "rgb(245, 158, 11)" : "rgb(59, 130, 246)";
            ctx.fillRect(
              anno.rect.x,
              anno.rect.y - 20,
              ctx.measureText(anno.componentName).width + 10,
              20
            );
            ctx.fillStyle = "rgb(255, 255, 255)";
            ctx.font = "14px Inter";
            ctx.fillText(anno.componentName, anno.rect.x + 5, anno.rect.y - 6);
          }
        });

        if (state.isDrawing) {
          // Draw the current rectangle being drawn
          ctx.strokeStyle = "rgb(245, 158, 11)";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);

          // Calculate proper rectangle coordinates for preview
          const minX = Math.min(state.startPos.x, state.startPos.x + state.currentRect.width);
          const minY = Math.min(state.startPos.y, state.startPos.y + state.currentRect.height);
          const width = Math.abs(state.currentRect.width);
          const height = Math.abs(state.currentRect.height);

          ctx.strokeRect(minX, minY, width, height);
          ctx.setLineDash([]);

          // Draw size indicator
          ctx.fillStyle = "rgb(245, 158, 11)";
          ctx.font = "12px Inter";
          const sizeText = `${Math.round(width)} × ${Math.round(height)}`;
          ctx.fillText(sizeText, minX + 5, minY - 5);
        }
      }

      function updateRightPanels() {
        updateLayerPanel();
        updatePropertyInspector();
      }

      function updateLayerPanel() {
        if (state.annotations.length === 0) {
          layerPanel.innerHTML =
            '<p class="text-sm text-gray-400 text-center">暂无标注</p>';
          return;
        }

        function renderTree(nodes, level, isSlotChild) {
          let html = "";
          nodes.forEach((anno) => {
            const isSelected = state.selectedAnnotationId === anno.id;
            const isRoot = anno.properties?.isRoot;
            const isContainer =
              anno.category === "slot" || anno.category === "container" || isRoot;
            const hasChildren = anno.children.length > 0;
            const isExpanded = state.expandedNodes.has(anno.id);

            // 页面根节点特殊样式
            const borderClass = isRoot
              ? (isSelected ? "border-green-500" : "border-green-400")
              : (isSelected ? "border-indigo-500" : "border-transparent");

            const bgClass = isRoot
              ? (isSelected ? "bg-green-50" : "bg-green-100")
              : (isSelected ? "selected" : "");

            const displayName = isRoot
              ? anno.properties?.name || anno.componentName
              : anno.componentName;

            // 展开/收缩图标
            let expandIcon = "";
            if (hasChildren) {
              expandIcon = isExpanded 
                ? '<span class="tree-toggle mr-1">▾</span>' 
                : '<span class="tree-toggle mr-1">▸</span>';
            } else {
              expandIcon = '<span class="tree-toggle mr-1" style="opacity: 0; pointer-events: none;">▸</span>';
            }

            html += `<div class="layer-item-wrapper">
                      <div class="layer-item p-2 rounded-md cursor-pointer border-l-4 ${bgClass} ${borderClass} ${
              isSlotChild ? "is-slot-child" : ""
            }" data-id="${anno.id}" style="padding-left: ${level * 20 + 8}px;">
                        ${expandIcon}
                        <span class="text-sm font-medium">${displayName} #${anno.id}</span>
                        ${isRoot ? '<span class="text-xs text-green-600 ml-2">(页面根节点)</span>' : ''}
                      </div>`;
            
            // 只在展开时渲染子节点
            if (hasChildren && isExpanded) {
              html += `<div class="layer-children">`;
              html += renderTree(anno.children, level + 1, isContainer);
              html += `</div>`;
            }
            
            html += `</div>`;
          });
          return html;
        }

        layerPanel.innerHTML = `<div class="space-y-1">${renderTree(
          state.annotations,
          0,
          false
        )}</div>`;
      }

      function updatePropertyInspector() {
        const selectedAnnotation = findAnnotation(state.selectedAnnotationId);
        if (!selectedAnnotation) {
          propertyInspector.innerHTML =
            '<p class="text-sm text-gray-400 text-center">请选择一个图层</p>';
          return;
        }

        const isRoot = selectedAnnotation.properties?.isRoot;

        let categoryText = "原子组件";
        let categoryColor = "text-blue-600";
        if (isRoot) {
          categoryText = "页面根节点";
          categoryColor = "text-green-600";
        } else if (selectedAnnotation.category === "slot") {
          categoryText = "带插槽组件";
          categoryColor = "text-green-600";
        } else if (selectedAnnotation.category === "business") {
          categoryText = "整体业务组件";
          categoryColor = "text-purple-600";
        } else if (selectedAnnotation.category === "container") {
          categoryText = "基础容器";
          categoryColor = "text-gray-600";
        }

        const displayName = isRoot
          ? selectedAnnotation.properties?.name || selectedAnnotation.componentName
          : selectedAnnotation.componentName;

        let html = `<div class="space-y-3 text-sm">
                <div><label class="font-semibold text-gray-700">组件名称:</label><p class="text-gray-900">${displayName}</p></div>
                <div><label class="font-semibold text-gray-700">分类:</label><p class="${categoryColor} font-medium">${categoryText}</p></div>
                <div><label class="font-semibold text-gray-700">位置大小 (x,y,w,h):</label><p class="text-gray-900">${Object.values(
                  selectedAnnotation.rect
                )
                  .map((v) => Math.round(v))
                  .join(", ")}</p></div>`;

        // 显示特殊信息
        if (isRoot) {
          html += `<div><label class="font-semibold text-gray-700">说明:</label><p class="text-green-600 text-xs">页面根节点覆盖整个画布，所有其他组件都应放置在其内部。</p></div>`;
        }

        html += `</div>`;

        if (
          selectedAnnotation.category === "slot" ||
          selectedAnnotation.category === "container" ||
          isRoot
        ) {
          html += `<div class="mt-4 pt-4 border-t"><h4 class="font-semibold text-gray-700 mb-2">容器信息</h4><p class="text-xs text-gray-500">此组件可包含子组件。绘制时如果新组件完全在此容器内且不与其他组件交叉，将自动成为其子组件。</p></div>`;
        } else {
          html += `<div class="mt-4 pt-4 border-t"><h4 class="font-semibold text-gray-700 mb-2">组件信息</h4><p class="text-xs text-gray-500">此类型组件内部不可包含子组件。</p></div>`;
        }

        // 页面根节点不能删除
        if (!isRoot) {
          html += `<div class="mt-6"><button id="delete-btn" data-id="${selectedAnnotation.id}" class="w-full bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition text-sm font-medium">删除此标注</button></div>`;
        } else {
          html += `<div class="mt-6"><p class="text-xs text-gray-400 text-center">页面根节点不能删除</p></div>`;
        }

        propertyInspector.innerHTML = html;
      }

      // --- 5. EVENT HANDLERS & LOGIC ---

      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
      }

      function selectAnnotationAt(pos) {
        let foundId = null;
        function findRecursive(nodes) {
          for (let i = nodes.length - 1; i >= 0; i--) {
            const anno = nodes[i];
            if (isInside(pos, anno.rect)) {
              // First check if there's a child annotation at this position
              const childFound = findRecursive(anno.children);
              if (childFound !== null) {
                foundId = childFound;
              } else if (foundId === null) {
                foundId = anno.id;
              }
              return foundId;
            }
          }
          return foundId;
        }
        return findRecursive(state.annotations);
      }

      function handleMouseDown(e) {
        if (!state.imageLoaded) return;
        e.preventDefault();

        try {
          const pos = getMousePos(e);

          // Check if the position is within canvas bounds
          if (pos.x < 0 || pos.x > canvas.width || pos.y < 0 || pos.y > canvas.height) {
            return;
          }

          if (state.selectedComponent) {
            // Start drawing
            state.isDrawing = true;
            state.startPos = pos;
            state.currentRect = {
              x: pos.x,
              y: pos.y,
              width: 0,
              height: 0,
            };
          } else {
            // Handle selection - 仅用于选择和查看标注，不影响绘制
            const clickedId = selectAnnotationAt(pos);
            if (state.selectedAnnotationId !== clickedId) {
              state.selectedAnnotationId = clickedId;

              // 更新提示信息
              if (clickedId !== null) {
                const clickedAnnotation = findAnnotation(clickedId);
                instruction.textContent = `已选中: ${clickedAnnotation.componentName} #${clickedId}，从左侧选择组件可继续标注`;
              } else {
                instruction.textContent = "从左侧选择组件开始标注";
              }

              draw();
              updateRightPanels();
            }
          }
        } catch (error) {
          console.error("Error in handleMouseDown:", error);
          state.isDrawing = false;
        }
      }

      function handleMouseMove(e) {
        if (!state.isDrawing) return;
        e.preventDefault();
        const currentPos = getMousePos(e);
        state.currentRect.width = currentPos.x - state.startPos.x;
        state.currentRect.height = currentPos.y - state.startPos.y;
        draw();
      }

      // 自动查找最合适的父容器（最小的包含此矩形的容器）
      function findBestParent(rect, searchTree = state.annotations, currentBest = null) {
        for (const anno of searchTree) {
          // 检查是否包含
          if (isInside(rect, anno.rect)) {
            // 检查此容器是否允许嵌套
            const allowsNesting = anno.category === "slot" || 
                                  anno.category === "container" || 
                                  anno.properties?.isRoot;
            
            if (allowsNesting) {
              // 递归查找更小的容器
              const betterParent = findBestParent(rect, anno.children, anno);
              return betterParent || anno;
            }
          }
        }
        return currentBest;
      }

      // 检查同级是否有交叉
      function checkSiblingIntersection(rect, siblings) {
        for (const sibling of siblings) {
          if (rectsIntersect(rect, sibling.rect)) {
            return sibling;
          }
        }
        return null;
      }

      function handleMouseUp(e) {
        if (!state.isDrawing) return;
        e.preventDefault();
        state.isDrawing = false;

        // Calculate the correct rectangle coordinates regardless of drag direction
        const minX = Math.min(state.startPos.x, state.startPos.x + state.currentRect.width);
        const minY = Math.min(state.startPos.y, state.startPos.y + state.currentRect.height);
        const maxX = Math.max(state.startPos.x, state.startPos.x + state.currentRect.width);
        const maxY = Math.max(state.startPos.y, state.startPos.y + state.currentRect.height);

        const finalRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };

        // Minimum size check
        if (finalRect.width < 5 || finalRect.height < 5) {
          draw();
          return;
        }

        // Ensure the rectangle is within canvas bounds
        if (finalRect.x < 0 || finalRect.y < 0 ||
            finalRect.x + finalRect.width > canvas.width ||
            finalRect.y + finalRect.height > canvas.height) {
          showMessage("标注区域不能超出图片边界！", "warning");
          draw();
          return;
        }

        // 自动查找最合适的父容器
        const parent = findBestParent(finalRect);
        
        if (!parent) {
          showMessage("绘制区域必须在页面根节点内部！", "warning");
          draw();
          return;
        }

        const searchScope = parent.children;

        // Rule 1: No intersection in the same level
        const intersectingSibling = checkSiblingIntersection(finalRect, searchScope);
        if (intersectingSibling) {
          showMessage(`标注不可以交叉！与组件 "${intersectingSibling.componentName} #${intersectingSibling.id}" 发生交叉`, "warning");
          draw();
          return;
        }

        // 创建新标注
        const newAnnotation = {
          id: state.nextId++,
          componentName: state.selectedComponent.name,
          category: state.selectedComponent.category,
          rect: finalRect,
          properties: {},
          children: [],
        };

        // 添加到父容器
        parent.children.push(newAnnotation);

        // 自动展开父节点，确保新节点可见
        state.expandedNodes.add(parent.id);

        // 自动选中新创建的组件
        state.selectedAnnotationId = newAnnotation.id;
        
        // 保持组件选择状态，允许连续绘制
        showMessage(`已创建 ${newAnnotation.componentName} #${newAnnotation.id}`, "success", 2000);
        instruction.textContent = `已创建 ${newAnnotation.componentName} #${newAnnotation.id}，可继续绘制或按 ESC 取消选择`;

        draw();
        updateRightPanels();
      }

      // --- 6. INITIALIZATION ---

      uploadBtn.addEventListener("click", () => {
        state.annotations = [];
        state.selectedAnnotationId = null;
        state.nextId = 0;
        state.selectedComponent = null;
        document
          .querySelectorAll(".component-item")
          .forEach((el) => el.classList.remove("selected"));

        if (!state.imageLoaded) {
          image.onload = () => {
            state.imageLoaded = true;
            placeholderText.style.display = "none";
            uploadBtn.textContent = "重置画布";
            resizeCanvas();

            // 创建默认的页面根节点
            createRootContainer();
          };
          if (image.complete) image.onload();
        } else {
          // 重置时也创建页面根节点
          createRootContainer();
          draw();
          updateRightPanels();
        }
      });

      // 创建页面根节点函数
      function createRootContainer() {
        // 清空现有标注
        state.annotations = [];
        state.nextId = 0;
        state.expandedNodes.clear(); // 清空展开状态

        // 创建覆盖整个画布的页面根节点
        const rootContainer = {
          id: state.nextId++,
          componentName: "Container",
          category: "container",
          rect: {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height
          },
          properties: {
            isRoot: true,
            name: "页面根节点"
          },
          children: [],
        };

        state.annotations.push(rootContainer);
        
        // 默认展开根节点
        state.expandedNodes.add(rootContainer.id);

        // 不自动选中页面根节点，让用户主动选择
        instruction.textContent = "页面根节点已创建，从左侧选择组件开始标注";
      }

      componentPalette.addEventListener("click", (e) => {
        const item = e.target.closest(".component-item");
        if (!item) return;

        const previouslySelected = document.querySelector(
          ".component-item.selected"
        );
        if (previouslySelected === item) {
          item.classList.remove("selected");
          state.selectedComponent = null;
          instruction.textContent = "已取消选择组件，点击现有标注可查看详情";
        } else {
          previouslySelected?.classList.remove("selected");
          item.classList.add("selected");
          state.selectedComponent = {
            name: item.dataset.name,
            category: item.dataset.category,
          };
          instruction.textContent = `已选择 ${state.selectedComponent.name}，直接在画布上拖拽绘制即可，系统将自动计算层级关系`;
        }
      });

      layerPanel.addEventListener("click", (e) => {
        // 检查是否点击了展开/收缩图标
        const toggleIcon = e.target.closest(".tree-toggle");
        if (toggleIcon) {
          e.stopPropagation();
          const item = e.target.closest(".layer-item");
          if (item) {
            const clickedId = parseInt(item.dataset.id, 10);
            const clickedAnnotation = findAnnotation(clickedId);
            
            // 切换展开状态
            if (clickedAnnotation.children.length > 0) {
              if (state.expandedNodes.has(clickedId)) {
                state.expandedNodes.delete(clickedId);
              } else {
                state.expandedNodes.add(clickedId);
              }
              updateLayerPanel();
            }
          }
          return;
        }

        // 点击节点进行选择
        const item = e.target.closest(".layer-item");
        if (item) {
          const clickedId = parseInt(item.dataset.id, 10);
          const clickedAnnotation = findAnnotation(clickedId);

          state.selectedAnnotationId = clickedId;

          // 更新提示信息 - 仅用于查看，不影响绘制
          instruction.textContent = `已选中: ${clickedAnnotation.componentName} #${clickedId}，从左侧选择组件可继续标注`;

          draw();
          updateRightPanels();
        }
      });

      // 双击节点展开/收缩
      layerPanel.addEventListener("dblclick", (e) => {
        const item = e.target.closest(".layer-item");
        if (item) {
          const clickedId = parseInt(item.dataset.id, 10);
          const clickedAnnotation = findAnnotation(clickedId);
          
          // 切换展开状态
          if (clickedAnnotation.children.length > 0) {
            if (state.expandedNodes.has(clickedId)) {
              state.expandedNodes.delete(clickedId);
            } else {
              state.expandedNodes.add(clickedId);
            }
            updateLayerPanel();
          }
        }
      });

      propertyInspector.addEventListener("click", (e) => {
        const button = e.target.closest("#delete-btn");
        if (button) {
          const idToDelete = parseInt(button.dataset.id, 10);
          if (confirm(`确定要删除标注 #${idToDelete} 及其所有子标注吗？`)) {
            deleteAnnotation(idToDelete);
            if (state.selectedAnnotationId === idToDelete) {
              state.selectedAnnotationId = null;
            }
            draw();
            updateRightPanels();
          }
        }
      });

      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("touchstart", handleMouseDown);
      canvas.addEventListener("touchmove", handleMouseMove);
      canvas.addEventListener("touchend", handleMouseUp);

      window.addEventListener("resize", resizeCanvas);

      // Expand/Collapse all tree nodes
      expandAllBtn.addEventListener("click", () => {
        state.expandedNodes.clear();
        forEachAnnotation((anno) => {
          if (anno.children.length > 0) {
            state.expandedNodes.add(anno.id);
          }
        });
        updateLayerPanel();
      });

      collapseAllBtn.addEventListener("click", () => {
        state.expandedNodes.clear();
        // 保持根节点展开
        if (state.annotations.length > 0 && state.annotations[0].properties?.isRoot) {
          state.expandedNodes.add(state.annotations[0].id);
        }
        updateLayerPanel();
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        // ESC key to cancel current operation
        if (e.key === "Escape") {
          state.isDrawing = false;
          state.selectedComponent = null;
          document
            .querySelectorAll(".component-item")
            .forEach((el) => el.classList.remove("selected"));
          instruction.textContent = "已取消选择，从左侧选择组件开始标注";
          draw();
        }

        // Delete key to remove selected annotation
        if (e.key === "Delete" && state.selectedAnnotationId !== null) {
          const selectedAnnotation = findAnnotation(state.selectedAnnotationId);
          // 不能删除页面根节点
          if (selectedAnnotation?.properties?.isRoot) {
            showMessage("页面根节点不能删除！", "warning");
            return;
          }
          if (selectedAnnotation && confirm(`确定要删除标注 #${selectedAnnotation.id} 及其所有子标注吗？`)) {
            deleteAnnotation(state.selectedAnnotationId);
            state.selectedAnnotationId = null;
            showMessage(`已删除标注 #${selectedAnnotation.id}`, "success");
            instruction.textContent = "已删除标注，从左侧选择组件继续标注";
            draw();
            updateRightPanels();
          }
        }
      });

      populateComponentPalette();
    </script>
  </body>
</html>
